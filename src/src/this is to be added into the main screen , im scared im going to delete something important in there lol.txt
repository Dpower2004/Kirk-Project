private Scene createSlotsScene(Stage stage) {
    final double SCREEN_WIDTH = 1280;
    final double SCREEN_HEIGHT = 720;
    
    // Create the main slot machine object
    Font marioFont = null;
    try {
        marioFont = Font.loadFont(new File("super_mario.ttf").toURI().toString(), 20);
        if (marioFont == null) {
            System.out.println("Failed to load super_mario.ttf - check file path");
            // Try loading from resources folder
            marioFont = Font.loadFont(getClass().getResourceAsStream("/fonts/super_mario.ttf"), 20);
        }
    } catch (Exception e) {
        System.out.println("Error loading font: " + e.getMessage());
    }
    
    // Array of image filenames representing different symbols on the slot machine
    final String[] SYMBOL_FILES = {
        "cherry.png", "lemon.png", "orange.png", "grape.png", "kirkDealer.png"
    };
    
    // Probability weights for each symbol
    final double[] SYMBOL_WEIGHTS = {
        0.20,  // cherry - common
        0.15,  // lemon  
        0.12,  // orange
        0.10,  // grape
        0.05   // kirkDealer - rare but achievable
    };
    
    //  0.25 to allow more matching possibilities
    final double THREE_DIFFERENT_SYMBOLS_PROBABILITY = 0.25;
    
    //  Add probability to force three matching symbols (20% chance)
    final double THREE_MATCHING_SYMBOLS_PROBABILITY = 0.20;
    
    // This gives kirkDealer a chance to appear even in the "three different" scenario
    final double KIRK_DEALER_IN_DIFFERENT_PROBABILITY = 0.15;
    
    // Initialize components
    ImageView[] reelImages = new ImageView[3];
    TextField betInput;
    Label balanceLabel;
    Label resultLabel;
    Random random = new Random();
    
    // Initialize audio
    MediaPlayer spinSound;
    MediaPlayer loseSound;
    
    try {
        Media spinMedia = new Media(new File("spin_sound_trimmed.mp3").toURI().toString());
        spinSound = new MediaPlayer(spinMedia);
        Media loseMedia = new Media(new File("youtube__asNhzXq72w_audio.mp3").toURI().toString());
        loseSound = new MediaPlayer(loseMedia);
    } catch (Exception e) {
        System.out.println("Error loading sound files: " + e.getMessage());
        spinSound = null;
        loseSound = null;
    }
    
    // Initialize balance (placeholder value)
    double[] balance = {1000};
    
    // Initialize main layout
    BorderPane root = new BorderPane();
    root.setPadding(new Insets(40));
    
    BackgroundImage backgroundImage = new BackgroundImage(
        new Image("file:slots.png"),
        BackgroundRepeat.NO_REPEAT,
        BackgroundRepeat.NO_REPEAT,
        BackgroundPosition.CENTER,
        new BackgroundSize(BackgroundSize.AUTO, BackgroundSize.AUTO, false, false, true, true)
    );
    root.setBackground(new Background(backgroundImage));
    
    // Create and style the header label
    Label headerLabel = new Label("KIRK'S SLOT MACHINE");
    if (marioFont != null) {
        headerLabel.setFont(Font.font(marioFont.getFamily(), FontWeight.BOLD, 48));
    } else {
        headerLabel.setFont(Font.font("Arial", FontWeight.BOLD, 48));
    }
    headerLabel.setTextFill(javafx.scene.paint.Color.WHITE);
    root.setTop(headerLabel);
    BorderPane.setAlignment(headerLabel, Pos.CENTER);
    BorderPane.setMargin(headerLabel, new Insets(0, 0, 50, 0));
    
    // Create container for the slot machine reels
    HBox reelsBox = new HBox(20);
    reelsBox.setAlignment(Pos.CENTER);
    reelsBox.setPadding(new Insets(-400,-420,30,-50));
    
    // Initialize each of the three reel image views
    for (int i = 0; i < 3; i++) {
        reelImages[i] = new ImageView();
        reelImages[i].setFitWidth(100);
        reelImages[i].setFitHeight(100);
        reelsBox.getChildren().add(reelImages[i]);
    }
    
    // Create and style the result message label
    resultLabel = new Label("Place your bet and spin!");
    if (marioFont != null) {
        resultLabel.setFont(Font.font(marioFont.getFamily(), FontWeight.BOLD, 24));
    } else {
        resultLabel.setFont(Font.font("Arial", FontWeight.BOLD, 24));
    }
    resultLabel.setTextFill(javafx.scene.paint.Color.RED);
    resultLabel.setAlignment(Pos.CENTER_LEFT);
    resultLabel.setMinWidth(100);
    StackPane.setAlignment(resultLabel, Pos.CENTER_LEFT);
    
    // Add these lines to create a box around the label
    resultLabel.setBackground(new Background(new BackgroundFill(
        javafx.scene.paint.Color.rgb(0, 0, 0, 0.7), // Semi-transparent black background
        new CornerRadii(10), // Rounded corners (10px radius)
        Insets.EMPTY
    )));
    resultLabel.setBorder(new Border(new BorderStroke(
        javafx.scene.paint.Color.GREEN, // GREEN border color
        BorderStrokeStyle.SOLID, // Solid border style
        new CornerRadii(10), // Rounded corners (10px radius)
        new BorderWidths(2) // 2px border width
    )));
    resultLabel.setPadding(new Insets(1, 20, 10, 20));
    resultLabel.setTranslateX(175);
    resultLabel.setTranslateY(-80);
    
    // Container for reels and result message
    VBox centerBox = new VBox(40);
    centerBox.setAlignment(Pos.CENTER);
    centerBox.setPadding(new Insets(200,0,0,-100));
    centerBox.getChildren().addAll(reelsBox, resultLabel);
    root.setCenter(centerBox);
    
    // Container for game controls (bet input, spin button)
    VBox controlsBox = new VBox(20);
    controlsBox.setAlignment(Pos.CENTER);
    
    // Create and style balance display label
    balanceLabel = new Label("BALANCE: $" + String.format("%.2f", balance[0]));
    if (marioFont != null) {
        balanceLabel.setFont(Font.font(marioFont.getFamily(), FontWeight.BOLD, 24));
    } else {
        balanceLabel.setFont(Font.font("Arial", FontWeight.BOLD, 24));
    }
    balanceLabel.setTextFill(javafx.scene.paint.Color.YELLOW);
    
    // Container for bet label and input field
    HBox betBox = new HBox(15);
    betBox.setAlignment(Pos.CENTER);
    
    // Create and style bet label
    Label betLabel = new Label("Your Bet: $");
    if (marioFont != null) {
        betLabel.setFont(Font.font(marioFont.getFamily(), 20));
    } else {
        betLabel.setFont(Font.font("Arial", 20));
    }
    betLabel.setTextFill(javafx.scene.paint.Color.WHITE);
    
    // Create and style bet input field
    betInput = new TextField();
    if (marioFont != null) {
        betInput.setFont(Font.font(marioFont.getFamily(), 20));
    } else {
        betInput.setFont(Font.font("Arial", 20));
    }
    betInput.setMaxWidth(200);
    betInput.setPromptText("Enter bet");
    
    // Add label and input field to bet container
    betBox.getChildren().addAll(betLabel, betInput);
    
    Button spinButton = new Button("SPIN");
    if (marioFont != null) {
        spinButton.setFont(Font.font(marioFont.getFamily(), FontWeight.BOLD, 24));
    } else {
        spinButton.setFont(Font.font("Arial", FontWeight.BOLD, 24));
    }
    spinButton.setMinWidth(70);
    spinButton.setMinHeight(40);
    spinButton.setTextFill(javafx.scene.paint.Color.RED);
    
    // Create a stack pane to overlay the spin button on the background
    StackPane overlayPane = new StackPane();
    overlayPane.getChildren().add(spinButton);
    // Position the button to align with handle in the top right
    StackPane.setAlignment(spinButton, Pos.TOP_RIGHT);
    StackPane.setMargin(spinButton, new Insets(-70, 160, 40, 30));
    // Set the overlay pane to cover the entire scene
    root.setRight(overlayPane);
    
    // Add back button to return to the main menu
    Button backButton = new Button("Return to Lobby");
    if (marioFont != null) {
        backButton.setFont(Font.font(marioFont.getFamily(), FontWeight.BOLD, 20));
    } else {
        backButton.setFont(Font.font("Arial", FontWeight.BOLD, 20));
    }
    backButton.setOnAction(e -> stage.setScene(createGameSelectScene(stage)));
    
    // Spin button action
    spinButton.setOnAction(e -> {
        try {
            // Parse bet amount from text field
            double betAmount = Double.parseDouble(betInput.getText());
            
            // Validate bet is positive
            if (betAmount <= 0) {
                resultLabel.setText("Please enter a valid bet amount!");
                return;
            }
            
            // Check if player has enough balance
            if (betAmount > balance[0]) {
                resultLabel.setText("Not enough money! Your balance is $" + String.format("%.2f", balance[0]));
                return;
            }
            
            // Deduct bet from balance
            balance[0] -= betAmount;
            if (spinSound != null) {
                spinSound.stop();
                spinSound.seek(javafx.util.Duration.ZERO);
                spinSound.play();
            }
            
            // Update balance display
            balanceLabel.setText("Balance: $" + String.format("%.2f", balance[0]));
            // Show spinning message
            resultLabel.setText("Spinning...");
            
            // Start the reels animation
            animateReels(() -> {
                int[] results = new int[3];
                
                // Random number to determine spin type
                double spinType = random.nextDouble();
                
                // Force three different symbols (25% chance)
                if (spinType < THREE_DIFFERENT_SYMBOLS_PROBABILITY) {
                    // Create a set to track which symbols we've already selected
                    HashSet<Integer> selectedSymbols = new HashSet<>();
                    
                    // For each reel
                    for (int i = 0; i < 3; i++) {
                        int symbolIndex;
                        // Keep generating random symbols until we get one we haven't used yet
                        do {
                            symbolIndex = getRandomSymbol(true, random, KIRK_DEALER_IN_DIFFERENT_PROBABILITY);
                        } while (selectedSymbols.contains(symbolIndex));
                        
                        selectedSymbols.add(symbolIndex);
                        results[i] = symbolIndex;
                        reelImages[i].setImage(new Image("file:" + SYMBOL_FILES[symbolIndex]));
                    }
                    
                    // All 3 are guaranteed to be different, so it's a loss
                    if (loseSound != null) {
                        loseSound.stop();
                        loseSound.seek(javafx.util.Duration.ZERO);
                        loseSound.play();
                    }
                }
                // Force three matching symbols (20% chance)
                else if (spinType < THREE_DIFFERENT_SYMBOLS_PROBABILITY + THREE_MATCHING_SYMBOLS_PROBABILITY) {
                    // Select one random symbol using weighted probabilities
                    int symbolIndex = getWeightedRandomSymbol(random, SYMBOL_WEIGHTS);
                    
                    // Set all three reels to show this symbol
                    for (int i = 0; i < 3; i++) {
                        results[i] = symbolIndex;
                        reelImages[i].setImage(new Image("file:" + SYMBOL_FILES[symbolIndex]));
                    }
                }
                // Regular weighted spin (now 55%)
                else {
                    // Generate results using weighted probability
                    for (int i = 0; i < 3; i++) {
                        results[i] = getWeightedRandomSymbol(random, SYMBOL_WEIGHTS);
                        reelImages[i].setImage(new Image("file:" + SYMBOL_FILES[results[i]]));
                    }
                }
                
                // Calculate winnings based on results
                double winnings = calculateWinnings(results, betAmount);
                
                // Update display based on win/loss
                if (winnings > 0) {
                    // Add winnings to balance
                    balance[0] += winnings + betAmount;
                    resultLabel.setText("You won $" + String.format("%.2f", winnings) + "!");
                } else {
                    resultLabel.setText("You lost $" + String.format("%.2f", betAmount));
                    // Play lose sound
                    if (loseSound != null) {
                        loseSound.stop();
                        loseSound.seek(javafx.util.Duration.ZERO);
                        loseSound.play();
                    }
                }
                
                // Update balance display
                balanceLabel.setText("Balance: $" + String.format("%.2f", balance[0]));
            });
            
        } catch (NumberFormatException ex) {
            // Handle case where input is not a valid number
            resultLabel.setText("Please enter a valid number!");
        }
    });
    
    // Add all controls to the controls container
    controlsBox.getChildren().addAll(balanceLabel, betBox, backButton);
    root.setBottom(controlsBox);
    BorderPane.setMargin(controlsBox, new Insets(40, 0, 0, 0));
    
    Scene scene = new Scene(root, SCREEN_WIDTH, SCREEN_HEIGHT);
    return scene;
}

// Helper methods needed for the slot machine

private void animateReels(Runnable onFinished) {
    Timeline timeline = new Timeline();
    int cycles = 30;
    
    // Create animation frames
    for (int i = 0; i < cycles; i++) {
        int index = i;
        // Add keyframe to the timeline
        timeline.getKeyFrames().add(new KeyFrame(Duration.millis(i * 75), e -> {
            // For each reel, show a random symbol during animation
            for (int j = 0; j < 3; j++) {
                int symbolIndex = getWeightedRandomSymbol(new Random(), new double[]{0.20, 0.15, 0.12, 0.10, 0.05});
                try {
                    ImageView[] reelImages = new ImageView[3]; // This will be replaced by the actual reelImages array
                    reelImages[j].setImage(new Image("file:" + new String[]{"cherry.png", "lemon.png", "orange.png", "grape.png", "kirkDealer.png"}[symbolIndex]));
                } catch (Exception ex) {
                    System.out.println("Error loading image during animation: " + ex.getMessage());
                }
            }
        }));
    }
    
    // Set action to run when animation completes
    timeline.setOnFinished(e -> onFinished.run());
    // Start the animation
    timeline.play();
}

private int getWeightedRandomSymbol(Random random, double[] symbolWeights) {
    double randomValue = random.nextDouble();
    double cumulativeProbability = 0.0;
    
    for (int i = 0; i < symbolWeights.length; i++) {
        cumulativeProbability += symbolWeights[i];
        if (randomValue < cumulativeProbability) {
            return i;
        }
    }
    
    // Fallback (shouldn't happen if weights sum to 1)
    return 0;
}

private int getRandomSymbol(boolean allowKirkDealer, Random random, double kirkDealerProbability) {
    // If kirkDealer is allowed and we roll the probability check
    if (allowKirkDealer && random.nextDouble() < kirkDealerProbability) {
        return 4; // Return kirkDealer index
    } else {
        // Only include indices 0-3 (fruits)
        return random.nextInt(4);
    }
}

private double calculateWinnings(int[] results, double betAmount) {
    // Count occurrences of each symbol
    int[] counts = new int[5]; // Match length to SYMBOL_FILES
    for (int r : results) {
        counts[r]++;  // Increment count for this symbol
    }
    
    // Check for triple match (3 of the same symbol)
    for (int i = 0; i < counts.length; i++) {
        if (counts[i] == 3) {
            switch (i) {
                case 0: return betAmount * 1.5;   // cherry - 1.5x multiplier
                case 1: return betAmount * 2;     // lemon - 2x multiplier
                case 2: return betAmount * 5;     // orange - 5x multiplier
                case 3: return betAmount * 10;    // grape - 10x multiplier
                case 4: return betAmount * 30;    // kirkDealer - 30x multiplier
            }
        }
    }
    
    // Check for double matches (2 of the same symbol)
    if (counts[0] == 2) return betAmount * 0.15;  // 2 cherries - 15% return
    if (counts[1] == 2) return betAmount * 0.25;  // 2 lemons - 25% return
    if (counts[2] == 2) return betAmount * 0.3;   // 2 oranges - 30% return
    if (counts[3] == 2) return betAmount * 0.4;   // 2 grapes - 40% return
    
    // kirkDealer gets more
    if (counts[4] == 2) return betAmount * 5;     // 2 kirkDealers - 5x multiplier
    
    // No matches
    return 0;  // Player loses their bet
}
